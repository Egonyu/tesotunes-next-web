<?php

use App\Models\ArtistPayout;
use App\Models\Artist;
use App\Models\ArtistRevenue;
use App\Models\Song;
use App\Models\User;
use App\Services\PayoutService;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

describe('ArtistPayout Model Security', function () {
    
    test('prevents mass assignment of protected financial fields', function () {
        $artist = Artist::factory()->create();
        
        // Attempt to mass assign protected fields
        $payout = ArtistPayout::create([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
            'amount' => 999999, // Should be ignored
            'status' => 'completed', // Should be ignored
            'transaction_id' => 'FAKE_ID', // Should be ignored
        ]);
        
        // Protected fields should not be set via mass assignment
        expect($payout->amount)->toBeNull();
        expect($payout->status)->toBe(ArtistPayout::STATUS_PENDING); // Default from observer
        expect($payout->transaction_id)->not->toBe('FAKE_ID'); // Generated by observer
    });

    test('requires explicit setter for amount field', function () {
        $artist = Artist::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        
        // Amount must be set explicitly
        $payout->amount = 100000;
        $payout->currency = 'UGX';
        $payout->status = ArtistPayout::STATUS_PENDING;
        $payout->save();
        
        expect((float)$payout->amount)->toBe(100000.0);
        expect($payout->currency)->toBe('UGX');
    });

    test('generates unique transaction ID automatically', function () {
        $artist = Artist::factory()->create();
        
        $payout1 = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout1->amount = 100000;
        $payout1->save();
        
        $payout2 = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout2->amount = 100000;
        $payout2->save();
        
        expect($payout1->transaction_id)->not->toBe($payout2->transaction_id);
        expect($payout1->transaction_id)->toStartWith('PAYOUT_');
        expect($payout2->transaction_id)->toStartWith('PAYOUT_');
    });

    test('calculates fees automatically', function () {
        $artist = Artist::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        
        $payout->amount = 100000;
        $payout->save();
        
        // Mobile money fee is 1.5%
        expect((float)$payout->fee_amount)->toBe(1500.0);
        expect((float)$payout->net_amount)->toBe(98500.0);
    });

    test('flags large payouts for review', function () {
        $artist = Artist::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        
        // Amount above threshold (2,000,000 UGX)
        $payout->amount = 2500000;
        $payout->save();
        
        $metadata = $payout->metadata ?? [];
        expect($metadata['requires_additional_review'] ?? false)->toBeTrue();
        expect($metadata['flagged_as_large_payout'] ?? false)->toBeTrue();
    });
});

describe('PayoutService Security', function () {
    
    test('enforces minimum payout amount', function () {
        $artist = Artist::factory()->create();
        $payoutService = app(PayoutService::class);
        
        // Below minimum (50,000 UGX)
        $result = $payoutService->requestPayout(
            $artist,
            30000,
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '256700000000']
        );
        
        expect($result['success'])->toBeFalse();
        expect($result['message'])->toContain('Minimum payout');
    });

    test('enforces maximum single payout amount', function () {
        $artist = Artist::factory()->create();
        $payoutService = app(PayoutService::class);
        
        // Above maximum (5,000,000 UGX)
        $result = $payoutService->requestPayout(
            $artist,
            6000000,
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '256700000000']
        );
        
        expect($result['success'])->toBeFalse();
        expect($result['message'])->toContain('Maximum single payout');
    });

    test('validates artist has sufficient balance', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        $payoutService = app(PayoutService::class);
        
        // Create some revenue for the artist
        $revenue = ArtistRevenue::create([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'earned_at' => now(),
            'reporting_month' => now()->format('Y-m'),
        ]);
        
        // Set financial fields (normally done by observers/services)
        $revenue->gross_amount = 50000;
        $revenue->net_amount = 35000;
        $revenue->save();
        
        // Request more than available
        $result = $payoutService->requestPayout(
            $artist,
            100000, // More than the 35,000 available
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '256700000000']
        );
        
        expect($result['success'])->toBeFalse();
        expect($result['message'])->toContain('Insufficient balance');
    });

    test('validates phone number format for mobile money', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        // Create sufficient revenue
        $revenue = ArtistRevenue::create([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'earned_at' => now(),
            'reporting_month' => now()->format('Y-m'),
        ]);
        
        $revenue->gross_amount = 100000;
        $revenue->net_amount = 70000;
        $revenue->save();
        
        $payoutService = app(PayoutService::class);
        
        // Invalid phone number format
        $result = $payoutService->requestPayout(
            $artist,
            60000,
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '0700000000'] // Should be 256700000000
        );
        
        expect($result['success'])->toBeFalse();
        expect($result['message'])->toContain('Invalid phone number');
    });

    test('enforces daily payout limit', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        // Create sufficient revenue
        $revenue = ArtistRevenue::create([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'earned_at' => now(),
            'reporting_month' => now()->format('Y-m'),
        ]);
        
        $revenue->gross_amount = 15000000;
        $revenue->net_amount = 12000000;
        $revenue->save();
        
        // Create a large pending payout today
        $existingPayout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $existingPayout->amount = 9000000;
        $existingPayout->status = ArtistPayout::STATUS_PENDING;
        $existingPayout->save();
        
        $payoutService = app(PayoutService::class);
        
        // Try to request another large payout (would exceed daily limit of 10,000,000)
        $result = $payoutService->requestPayout(
            $artist,
            2000000,
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '256700000000']
        );
        
        expect($result['success'])->toBeFalse();
        expect($result['message'])->toContain('Daily payout limit');
    });

    test('uses database transactions for payout requests', function () {
        $artist = Artist::factory()->create();
        $payoutService = app(PayoutService::class);
        
        // Invalid request should rollback
        $result = $payoutService->requestPayout(
            $artist,
            30000, // Below minimum
            ArtistPayout::METHOD_MOBILE_MONEY,
            ['phone_number' => '256700000000']
        );
        
        expect($result['success'])->toBeFalse();
        
        // No payout record should be created
        $payoutCount = ArtistPayout::where('artist_id', $artist->id)->count();
        expect($payoutCount)->toBe(0);
    });
});

describe('Payout Approval Workflow', function () {
    
    test('only finance/admin roles can approve payouts', function () {
        $artist = Artist::factory()->create();
        $user = User::factory()->create();
        $financeUser = User::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout->amount = 100000;
        $payout->status = ArtistPayout::STATUS_PENDING;
        $payout->save();
        
        $payoutService = app(PayoutService::class);
        
        // Regular user cannot approve - expect exception
        try {
            $payoutService->approvePayout($payout, $user);
            expect(true)->toBeFalse(); // Should not reach here
        } catch (Exception $e) {
            expect($e->getMessage())->toContain('Insufficient permissions');
        }
        
        // Finance user can approve (would need to mock revenue check)
        // This would normally work but requires proper setup
        // $result = $payoutService->approvePayout($payout, $financeUser);
    });

    test('payout status transitions are validated', function () {
        $artist = Artist::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout->amount = 100000;
        $payout->status = ArtistPayout::STATUS_PENDING;
        $payout->save();
        
        // Valid transition: pending -> approved
        $financeUser = User::factory()->create();
        $payout->markAsApproved($financeUser);
        expect($payout->status)->toBe(ArtistPayout::STATUS_APPROVED);
        
        // Valid transition: approved -> processing
        $payout->markAsProcessing();
        expect($payout->status)->toBe(ArtistPayout::STATUS_PROCESSING);
        
        // Valid transition: processing -> completed
        $payout->markAsCompleted();
        expect($payout->status)->toBe(ArtistPayout::STATUS_COMPLETED);
    });

    test('cannot approve already processed payout', function () {
        $artist = Artist::factory()->create();
        $financeUser = User::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout->amount = 100000;
        $payout->status = ArtistPayout::STATUS_COMPLETED;
        $payout->save();
        
        expect($payout->canBeApproved())->toBeFalse();
    });

    test('can retry failed payout', function () {
        $artist = Artist::factory()->create();
        
        $payout = new ArtistPayout([
            'artist_id' => $artist->id,
            'payout_method' => 'mobile_money',
            'phone_number' => '256700000000',
        ]);
        $payout->amount = 100000;
        $payout->status = ArtistPayout::STATUS_FAILED;
        $payout->failure_reason = 'Network error';
        $payout->save();
        
        expect($payout->canBeRetried())->toBeTrue();
    });
});

describe('ArtistRevenue Model Security', function () {
    
    test('prevents mass assignment of protected financial fields', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        // Attempt to mass assign protected fields
        $revenue = ArtistRevenue::create([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'gross_amount' => 999999, // Should be ignored
            'net_amount' => 999999, // Should be ignored
            'status' => 'paid', // Should be ignored
            'currency' => 'UGX',
            'earned_at' => now(),
            'reporting_month' => now()->format('Y-m'),
        ]);
        
        // Protected fields should not be set via mass assignment
        expect($revenue->gross_amount)->toBeNull();
        expect($revenue->net_amount)->toBeNull();
        expect($revenue->status)->toBe('pending'); // Default from observer
    });

    test('validates revenue calculations', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        $revenue = new ArtistRevenue([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'reporting_month' => now()->format('Y-m'),
            'earned_at' => now(),
        ]);
        
        // Set financial fields explicitly
        $revenue->gross_amount = 100.00;
        $revenue->platform_fee = 30.00; // 30%
        $revenue->distribution_fee = 10.00; // 10%
        $revenue->net_amount = 60.00; // Should be 100 - 30 - 10 = 60
        $revenue->save();
        
        // Observer validates this calculation
        expect((float)$revenue->net_amount)->toBe(60.0);
    });

    test('detects negative revenue amounts', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        $revenue = new ArtistRevenue([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'reporting_month' => now()->format('Y-m'),
            'earned_at' => now(),
        ]);
        
        // Set negative amount (should be logged as error)
        $revenue->gross_amount = 100.00;
        $revenue->net_amount = -10.00; // Negative!
        $revenue->save();
        
        // Observer detects and logs this anomaly
        expect((float)$revenue->net_amount)->toBe(-10.0);
        // In production, this triggers an audit alert
    });

    test('validates artist share percentage range', function () {
        $artist = Artist::factory()->create();
        $song = Song::factory()->create(['artist_id' => $artist->id]);
        
        $revenue = new ArtistRevenue([
            'artist_id' => $artist->id,
            'song_id' => $song->id,
            'revenue_type' => 'stream',
            'platform' => 'spotify',
            'reporting_month' => now()->format('Y-m'),
            'earned_at' => now(),
        ]);
        
        $revenue->gross_amount = 100.00;
        $revenue->net_amount = 70.00;
        $revenue->artist_share_percentage = 150.00; // Invalid! Should be 0-100
        $revenue->save();
        
        // Observer logs this as error
        expect((float)$revenue->artist_share_percentage)->toBe(150.0);
        // In production, this triggers validation error log
    });
});
